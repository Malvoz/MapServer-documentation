.. index::
   pair: Optimization; Vector

.. _vector_optimization:

*****************************************************************************
 Vector Data Management & Optimization
*****************************************************************************

:Author: Jeff McKenna
:Contact: jmckenna at gatewaygeomatics.com
:Original Author: HostGIS
:Last Updated: 2021-04-12

.. contents:: Table of Contents
    :depth: 3
    :backlinks: top
    
Choose the right vector format for your needs
---------------------------------------------

- The best/optimal vector data source for MapServer in terms of speed-of-display
  is `.shp <https://gdal.org/drivers/vector/shapefile.html#vector-shapefile>`__.

- For databases, MapServer displays `PostGIS <https://gdal.org/drivers/vector/pg.html>`__ 
  layers very fast, and some custom tricks are included in the MapServer source 
  specifically for PostGIS + MapServer draw speed.  PostGIS is therefore recommended.
  
- `SpatiaLite <https://gdal.org/drivers/vector/sqlite.html>`__ is recommended
  for those who require a portable format, and works very well with MapServer.

Index your data
---------------

This of course must be your first step for any vector layer, for fast display 
in MapServer.  See :ref:`tileindex` for more detailed information. 

Splitting your data
-------------------

If you find yourself making several layers, all of them using the same dataset
but filtering to only use some of the records, you could probably do it
better. If the criteria are static, one approach is to pre-split the data.

The *ogr2ogr* utility can select on certain features from a datasource, and
save them to a new data source. Thus, you can split your dataset into several
smaller ones that are already effectively filtered, and remove the FILTER
statement.

If you are using shapefiles, the `shp2tile <https://github.com/woodbri/imaptools.com>`__
utility is a wonderful commandline tool for this.
  
.. NOTE::
    For Windows users, `MS4W <https://ms4w.com>`__ includes the shp2tile utility, and 
    all utilities mentioned here.

.. index::
   pair: Optimization; Shape datasets
   
Handling your vector LAYERS in the mapfile
------------------------------------------

Please review the notes in the document :ref:`mapfile_tuning`.

Shapefile Notes
---------------
Use :ref:`shptree` to generate a spatial index on your shapefile. This is
quick and easy ("shptree foo.shp") and generates a .qix file. MapServer will
automagically detect an index and use it.

.. note::

    Tileindexes can also be indexed with :ref:`shptree`.

MapServer also comes with the :ref:`sortshp` utility. This reorganizes a
shapefile, sorting it according to the values in one of its columns. If you're
commonly filtering by criteria and it's almost always by a specific column,
this can make the process slightly more efficient.

Although shapefiles are a very fast data format, :ref:`PostGIS
<input_postgis>` is pretty speedy as well, especially if you use indexes well
and have memory to throw at caching.

.. index::
   pair: Optimization; PostGIS

PostGIS Notes
-------------

Indexing with PostGIS
^^^^^^^^^^^^^^^^^^^^^

The single biggest boost to performance is indexing. Make sure that there's a
GIST index on the geometry column, and each record should also have an indexed
primary key. If you used shp2pgsql, then these statements should create the
necessary indexes:

.. code-block:: sql

    ALTER TABLE table ADD PRIMARY KEY (gid);
    CREATE INDEX table_the_geom ON table (the_geom) USING GIST;

PostgreSQL also supports reorganizing the data in a table, such that it's
physically sorted by the index. This allows PostgreSQL to be much more
efficient in reading the indexed data. Use the 
`CLUSTER command <https://www.postgresql.org/docs/current/sql-cluster.html>`__, 
e.g.

.. code-block:: sql 

    CLUSTER the_geom ON table;

Then there are numerous optimizations one can perform on the database server
itself, aside from the geospatial component. The easiest is to increase
*shared_buffers* in the *postgresql.conf* file, which allows PostgreSQL to use
more memory for caching. It is worth the time to investigate the various options
in the `Resource Consumption <https://www.postgresql.org/docs/current/runtime-config-resource.html>`__
section of the PostgreSQL documentation.

Debugging speed issues with PostGIS
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

You may face a situation where your PostGIS table is drawing slowly in MapServer. 
The following steps will help you examine the issue (using a WFS case) :

- Always start by getting the draw time for your layer, with a :ref:`shp2img` 
  command:

    ::

      shp2img -m postgis-wfs.map -o ttt.png -map_debug 3

        msDrawMap(): Layer 0 (provinces), 1.587s
        msDrawMap(): Drawing Label Cache, 0.000s
        msDrawMap() total time: 1.589s
        msSaveImage(ttt.png) total time: 0.005s
        freeLayer(): freeing layer at 010E0EC0.
        msPostGISLayerIsOpen called.
        msConnPoolClose(host=127.0.0.1 user=postgres password=postgres port=5432 dbname=gmap,01197840)

- To diagnose if the problem is with your PostGIS table configuration, or with
  MapServer, execute the exact request sent by MapServer, at the psql.exe 
  commandline, by doing the following steps:
  
    - add into your MAP-level of your mapfile:

       .. code-block:: mapfile 

         CONFIG "CPL_DEBUG" "ON"
         CONFIG "MS_ERRORFILE" "/ms4w/tmp/ms_error.txt"
         DEBUG 5

    - add into your PostGIS LAYER of your mapfile:

       .. code-block:: mapfile 

         DEBUG 5

    - now use a WFS client such as QGIS and add your WFS PostGIS layer

    - open  "/ms4w/tmp/ms_error.txt" in Notepad++

    - search for "msPostGISLayerWhichShapes query:"

    - that line should list the long exact query sent from MapServer to the 
      PostreSQL instance, it may look like:

        ::
        
           [Mon Apr 12 11:27:34 2021].207000 msPostGISLayerWhichShapes query: 
            SELECT "gid"::text,"area"::text,"perimeter"::text,"province_"::text,"province_i"::text,"status"::text,"name"::text,"name_e"::text,"name_f"::text,"reg_code"::text,"poly_featu"::text,"island"::text,"island_e"::text,"island_f"::text,ST_AsBinary(("geom"),'NDR') 
            as geom,"gid"::text FROM province WHERE "geom" && 
            ST_GeomFromText('POLYGON((-5814679.36987815 
            -1504714.04276694,-5814679.36987815 4439806.52253364,5943763.33635122 
            4439806.52253364,5943763.33635122 -1504714.04276694,-5814679.36987815 
            -1504714.04276694))',3978) LIMIT 2 OFFSET 0

    - now connect to that database through psql.exe

        ::
        
           psql -U postgres -p 5432 -d mydb

    - using that error file line, grab everything from "SELECT", and inside 
      your database prompt, start the command with "EXPLAIN ANALYZE" and then 
      paste your full query, such as:

        ::
        
            mydb=# EXPLAIN ANALYZE SELECT 
            "gid"::text,"area"::text,"perimeter"::text,"province_"::text,"province_i"::text,"status"::text,"name"::text,"name_e"::text,"name_f"::text,"reg_code"::text,"poly_featu"::text,"island"::text,"island_e"::text,"island_f"::text,ST_AsBinary(("geom"),'NDR') 
            as geom,"gid"::text FROM province WHERE "geom" && 
            ST_GeomFromText('POLYGON((-5814679.36987815 
            -1504714.04276694,-5814679.36987815 4439806.52253364,5943763.33635122 
            4439806.52253364,5943763.33635122 -1504714.04276694,-5814679.36987815 
            -1504714.04276694))',3978) LIMIT 2 OFFSET 0;

    - the response will tell you how long that query took, such as:

        ::

         Execution time: 0.293 ms
     
    - if the query takes a long time to execute at the psql commandline, then you know
      to focus your efforts on improving the indexing/settings of your PostGIS table.

.. index::
   pair: Optimization; Databases

Databases in General (PostGIS, Oracle, SpatiaLite, Microsoft SQL Server, MySQL)
-------------------------------------------------------------------------------

Enable Connection Pooling
^^^^^^^^^^^^^^^^^^^^^^^^^

By default, MapServer opens and closes a new database connection for each
database-driven layer in the mapfile. If you have several layers reading from
the same database, this doesn't make a lot of sense. And with some databases
(such as Oracle) establishing connections takes enough time that it can become
significant.

Try adding this line to your database layers:

.. code-block:: mapfile 

    PROCESSING "CLOSE_CONNECTION=DEFER"

This causes MapServer to not close the database connection for each layer until
after it has finished processing the mapfile and this may shave a few seconds
off of map generation times.

Set EXTENT at the LAYER level of mapfile
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Also for performance, each of your LAYERs with a database connection should 
have EXTENT set at the layer level, such as:

   .. code-block:: mapfile

          /* my database layer */
          LAYER
            NAME "provinces"
            TYPE POLYGON
            STATUS ON
            CONNECTIONTYPE postgis
            CONNECTION "host=127.0.0.1 user=postgres password=postgres port=5432 dbname=gmap"
            DATA "geom FROM province USING unique gid using srid=3978"
            EXTENT -2340603.75 -719746.0625 3009430.5 3836605.25
            PROJECTION
              "init=epsg:3978"
            END # projection
            ...
          END # layer
          
.. tip::

    PostGIS users can use the *ST_Extent()* function to get the bounding box of a table,
    such as ::
     
      SELECT ST_Extent(geom) as table_extent FROM province;
      
      
                    table_extent
      ----------------------------------------------------
          BOX(-2340603.75 -719746.0625,3009430.5 3836605.25)
      (1 row) 